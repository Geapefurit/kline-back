// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/Geapefurit/kline-back/zeus/pkg/db/ent/kpoint"
	"github.com/Geapefurit/kline-back/zeus/pkg/db/ent/kprice"
	"github.com/Geapefurit/kline-back/zeus/pkg/db/ent/predicate"
	"github.com/Geapefurit/kline-back/zeus/pkg/db/ent/token"
	"github.com/Geapefurit/kline-back/zeus/pkg/db/ent/tokenpair"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeKPoint    = "KPoint"
	TypeKPrice    = "KPrice"
	TypeToken     = "Token"
	TypeTokenPair = "TokenPair"
)

// KPointMutation represents an operation that mutates the KPoint nodes in the graph.
type KPointMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	token_pair_id    *uint32
	addtoken_pair_id *int32
	k_point_type     *string
	open             *float64
	addopen          *float64
	high             *float64
	addhigh          *float64
	low              *float64
	addlow           *float64
	close            *float64
	addclose         *float64
	start_time       *uint32
	addstart_time    *int32
	end_time         *uint32
	addend_time      *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*KPoint, error)
	predicates       []predicate.KPoint
}

var _ ent.Mutation = (*KPointMutation)(nil)

// kpointOption allows management of the mutation configuration using functional options.
type kpointOption func(*KPointMutation)

// newKPointMutation creates new mutation for the KPoint entity.
func newKPointMutation(c config, op Op, opts ...kpointOption) *KPointMutation {
	m := &KPointMutation{
		config:        c,
		op:            op,
		typ:           TypeKPoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKPointID sets the ID field of the mutation.
func withKPointID(id uint32) kpointOption {
	return func(m *KPointMutation) {
		var (
			err   error
			once  sync.Once
			value *KPoint
		)
		m.oldValue = func(ctx context.Context) (*KPoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KPoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKPoint sets the old KPoint of the mutation.
func withKPoint(node *KPoint) kpointOption {
	return func(m *KPointMutation) {
		m.oldValue = func(context.Context) (*KPoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KPointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KPointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KPoint entities.
func (m *KPointMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KPointMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KPointMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KPoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KPointMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KPointMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *KPointMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *KPointMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KPointMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KPointMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KPointMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *KPointMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *KPointMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KPointMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KPointMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KPointMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *KPointMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *KPointMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KPointMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTokenPairID sets the "token_pair_id" field.
func (m *KPointMutation) SetTokenPairID(u uint32) {
	m.token_pair_id = &u
	m.addtoken_pair_id = nil
}

// TokenPairID returns the value of the "token_pair_id" field in the mutation.
func (m *KPointMutation) TokenPairID() (r uint32, exists bool) {
	v := m.token_pair_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenPairID returns the old "token_pair_id" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldTokenPairID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenPairID: %w", err)
	}
	return oldValue.TokenPairID, nil
}

// AddTokenPairID adds u to the "token_pair_id" field.
func (m *KPointMutation) AddTokenPairID(u int32) {
	if m.addtoken_pair_id != nil {
		*m.addtoken_pair_id += u
	} else {
		m.addtoken_pair_id = &u
	}
}

// AddedTokenPairID returns the value that was added to the "token_pair_id" field in this mutation.
func (m *KPointMutation) AddedTokenPairID() (r int32, exists bool) {
	v := m.addtoken_pair_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenPairID resets all changes to the "token_pair_id" field.
func (m *KPointMutation) ResetTokenPairID() {
	m.token_pair_id = nil
	m.addtoken_pair_id = nil
}

// SetKPointType sets the "k_point_type" field.
func (m *KPointMutation) SetKPointType(s string) {
	m.k_point_type = &s
}

// KPointType returns the value of the "k_point_type" field in the mutation.
func (m *KPointMutation) KPointType() (r string, exists bool) {
	v := m.k_point_type
	if v == nil {
		return
	}
	return *v, true
}

// OldKPointType returns the old "k_point_type" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldKPointType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKPointType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKPointType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKPointType: %w", err)
	}
	return oldValue.KPointType, nil
}

// ClearKPointType clears the value of the "k_point_type" field.
func (m *KPointMutation) ClearKPointType() {
	m.k_point_type = nil
	m.clearedFields[kpoint.FieldKPointType] = struct{}{}
}

// KPointTypeCleared returns if the "k_point_type" field was cleared in this mutation.
func (m *KPointMutation) KPointTypeCleared() bool {
	_, ok := m.clearedFields[kpoint.FieldKPointType]
	return ok
}

// ResetKPointType resets all changes to the "k_point_type" field.
func (m *KPointMutation) ResetKPointType() {
	m.k_point_type = nil
	delete(m.clearedFields, kpoint.FieldKPointType)
}

// SetOpen sets the "open" field.
func (m *KPointMutation) SetOpen(f float64) {
	m.open = &f
	m.addopen = nil
}

// Open returns the value of the "open" field in the mutation.
func (m *KPointMutation) Open() (r float64, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldOpen(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// AddOpen adds f to the "open" field.
func (m *KPointMutation) AddOpen(f float64) {
	if m.addopen != nil {
		*m.addopen += f
	} else {
		m.addopen = &f
	}
}

// AddedOpen returns the value that was added to the "open" field in this mutation.
func (m *KPointMutation) AddedOpen() (r float64, exists bool) {
	v := m.addopen
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpen resets all changes to the "open" field.
func (m *KPointMutation) ResetOpen() {
	m.open = nil
	m.addopen = nil
}

// SetHigh sets the "high" field.
func (m *KPointMutation) SetHigh(f float64) {
	m.high = &f
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *KPointMutation) High() (r float64, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldHigh(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds f to the "high" field.
func (m *KPointMutation) AddHigh(f float64) {
	if m.addhigh != nil {
		*m.addhigh += f
	} else {
		m.addhigh = &f
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *KPointMutation) AddedHigh() (r float64, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ResetHigh resets all changes to the "high" field.
func (m *KPointMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
}

// SetLow sets the "low" field.
func (m *KPointMutation) SetLow(f float64) {
	m.low = &f
	m.addlow = nil
}

// Low returns the value of the "low" field in the mutation.
func (m *KPointMutation) Low() (r float64, exists bool) {
	v := m.low
	if v == nil {
		return
	}
	return *v, true
}

// OldLow returns the old "low" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldLow(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLow: %w", err)
	}
	return oldValue.Low, nil
}

// AddLow adds f to the "low" field.
func (m *KPointMutation) AddLow(f float64) {
	if m.addlow != nil {
		*m.addlow += f
	} else {
		m.addlow = &f
	}
}

// AddedLow returns the value that was added to the "low" field in this mutation.
func (m *KPointMutation) AddedLow() (r float64, exists bool) {
	v := m.addlow
	if v == nil {
		return
	}
	return *v, true
}

// ResetLow resets all changes to the "low" field.
func (m *KPointMutation) ResetLow() {
	m.low = nil
	m.addlow = nil
}

// SetClose sets the "close" field.
func (m *KPointMutation) SetClose(f float64) {
	m.close = &f
	m.addclose = nil
}

// Close returns the value of the "close" field in the mutation.
func (m *KPointMutation) Close() (r float64, exists bool) {
	v := m.close
	if v == nil {
		return
	}
	return *v, true
}

// OldClose returns the old "close" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldClose(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClose: %w", err)
	}
	return oldValue.Close, nil
}

// AddClose adds f to the "close" field.
func (m *KPointMutation) AddClose(f float64) {
	if m.addclose != nil {
		*m.addclose += f
	} else {
		m.addclose = &f
	}
}

// AddedClose returns the value that was added to the "close" field in this mutation.
func (m *KPointMutation) AddedClose() (r float64, exists bool) {
	v := m.addclose
	if v == nil {
		return
	}
	return *v, true
}

// ResetClose resets all changes to the "close" field.
func (m *KPointMutation) ResetClose() {
	m.close = nil
	m.addclose = nil
}

// SetStartTime sets the "start_time" field.
func (m *KPointMutation) SetStartTime(u uint32) {
	m.start_time = &u
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *KPointMutation) StartTime() (r uint32, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldStartTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds u to the "start_time" field.
func (m *KPointMutation) AddStartTime(u int32) {
	if m.addstart_time != nil {
		*m.addstart_time += u
	} else {
		m.addstart_time = &u
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *KPointMutation) AddedStartTime() (r int32, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *KPointMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *KPointMutation) SetEndTime(u uint32) {
	m.end_time = &u
	m.addend_time = nil
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *KPointMutation) EndTime() (r uint32, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the KPoint entity.
// If the KPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPointMutation) OldEndTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// AddEndTime adds u to the "end_time" field.
func (m *KPointMutation) AddEndTime(u int32) {
	if m.addend_time != nil {
		*m.addend_time += u
	} else {
		m.addend_time = &u
	}
}

// AddedEndTime returns the value that was added to the "end_time" field in this mutation.
func (m *KPointMutation) AddedEndTime() (r int32, exists bool) {
	v := m.addend_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *KPointMutation) ResetEndTime() {
	m.end_time = nil
	m.addend_time = nil
}

// Where appends a list predicates to the KPointMutation builder.
func (m *KPointMutation) Where(ps ...predicate.KPoint) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KPointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KPoint).
func (m *KPointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KPointMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, kpoint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kpoint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kpoint.FieldDeletedAt)
	}
	if m.token_pair_id != nil {
		fields = append(fields, kpoint.FieldTokenPairID)
	}
	if m.k_point_type != nil {
		fields = append(fields, kpoint.FieldKPointType)
	}
	if m.open != nil {
		fields = append(fields, kpoint.FieldOpen)
	}
	if m.high != nil {
		fields = append(fields, kpoint.FieldHigh)
	}
	if m.low != nil {
		fields = append(fields, kpoint.FieldLow)
	}
	if m.close != nil {
		fields = append(fields, kpoint.FieldClose)
	}
	if m.start_time != nil {
		fields = append(fields, kpoint.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, kpoint.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KPointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kpoint.FieldCreatedAt:
		return m.CreatedAt()
	case kpoint.FieldUpdatedAt:
		return m.UpdatedAt()
	case kpoint.FieldDeletedAt:
		return m.DeletedAt()
	case kpoint.FieldTokenPairID:
		return m.TokenPairID()
	case kpoint.FieldKPointType:
		return m.KPointType()
	case kpoint.FieldOpen:
		return m.Open()
	case kpoint.FieldHigh:
		return m.High()
	case kpoint.FieldLow:
		return m.Low()
	case kpoint.FieldClose:
		return m.Close()
	case kpoint.FieldStartTime:
		return m.StartTime()
	case kpoint.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KPointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kpoint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kpoint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kpoint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kpoint.FieldTokenPairID:
		return m.OldTokenPairID(ctx)
	case kpoint.FieldKPointType:
		return m.OldKPointType(ctx)
	case kpoint.FieldOpen:
		return m.OldOpen(ctx)
	case kpoint.FieldHigh:
		return m.OldHigh(ctx)
	case kpoint.FieldLow:
		return m.OldLow(ctx)
	case kpoint.FieldClose:
		return m.OldClose(ctx)
	case kpoint.FieldStartTime:
		return m.OldStartTime(ctx)
	case kpoint.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown KPoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KPointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kpoint.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kpoint.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kpoint.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kpoint.FieldTokenPairID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenPairID(v)
		return nil
	case kpoint.FieldKPointType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKPointType(v)
		return nil
	case kpoint.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case kpoint.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case kpoint.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLow(v)
		return nil
	case kpoint.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClose(v)
		return nil
	case kpoint.FieldStartTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case kpoint.FieldEndTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown KPoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KPointMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, kpoint.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, kpoint.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, kpoint.FieldDeletedAt)
	}
	if m.addtoken_pair_id != nil {
		fields = append(fields, kpoint.FieldTokenPairID)
	}
	if m.addopen != nil {
		fields = append(fields, kpoint.FieldOpen)
	}
	if m.addhigh != nil {
		fields = append(fields, kpoint.FieldHigh)
	}
	if m.addlow != nil {
		fields = append(fields, kpoint.FieldLow)
	}
	if m.addclose != nil {
		fields = append(fields, kpoint.FieldClose)
	}
	if m.addstart_time != nil {
		fields = append(fields, kpoint.FieldStartTime)
	}
	if m.addend_time != nil {
		fields = append(fields, kpoint.FieldEndTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KPointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kpoint.FieldCreatedAt:
		return m.AddedCreatedAt()
	case kpoint.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case kpoint.FieldDeletedAt:
		return m.AddedDeletedAt()
	case kpoint.FieldTokenPairID:
		return m.AddedTokenPairID()
	case kpoint.FieldOpen:
		return m.AddedOpen()
	case kpoint.FieldHigh:
		return m.AddedHigh()
	case kpoint.FieldLow:
		return m.AddedLow()
	case kpoint.FieldClose:
		return m.AddedClose()
	case kpoint.FieldStartTime:
		return m.AddedStartTime()
	case kpoint.FieldEndTime:
		return m.AddedEndTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KPointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kpoint.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case kpoint.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case kpoint.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case kpoint.FieldTokenPairID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenPairID(v)
		return nil
	case kpoint.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpen(v)
		return nil
	case kpoint.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case kpoint.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLow(v)
		return nil
	case kpoint.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClose(v)
		return nil
	case kpoint.FieldStartTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case kpoint.FieldEndTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown KPoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KPointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kpoint.FieldKPointType) {
		fields = append(fields, kpoint.FieldKPointType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KPointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KPointMutation) ClearField(name string) error {
	switch name {
	case kpoint.FieldKPointType:
		m.ClearKPointType()
		return nil
	}
	return fmt.Errorf("unknown KPoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KPointMutation) ResetField(name string) error {
	switch name {
	case kpoint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kpoint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kpoint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kpoint.FieldTokenPairID:
		m.ResetTokenPairID()
		return nil
	case kpoint.FieldKPointType:
		m.ResetKPointType()
		return nil
	case kpoint.FieldOpen:
		m.ResetOpen()
		return nil
	case kpoint.FieldHigh:
		m.ResetHigh()
		return nil
	case kpoint.FieldLow:
		m.ResetLow()
		return nil
	case kpoint.FieldClose:
		m.ResetClose()
		return nil
	case kpoint.FieldStartTime:
		m.ResetStartTime()
		return nil
	case kpoint.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown KPoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KPointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KPointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KPointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KPointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KPointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KPointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KPointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KPoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KPointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KPoint edge %s", name)
}

// KPriceMutation represents an operation that mutates the KPrice nodes in the graph.
type KPriceMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	token_pair_id    *uint32
	addtoken_pair_id *int32
	price            *float64
	addprice         *float64
	time             *uint32
	addtime          *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*KPrice, error)
	predicates       []predicate.KPrice
}

var _ ent.Mutation = (*KPriceMutation)(nil)

// kpriceOption allows management of the mutation configuration using functional options.
type kpriceOption func(*KPriceMutation)

// newKPriceMutation creates new mutation for the KPrice entity.
func newKPriceMutation(c config, op Op, opts ...kpriceOption) *KPriceMutation {
	m := &KPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeKPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKPriceID sets the ID field of the mutation.
func withKPriceID(id uint32) kpriceOption {
	return func(m *KPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *KPrice
		)
		m.oldValue = func(ctx context.Context) (*KPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKPrice sets the old KPrice of the mutation.
func withKPrice(node *KPrice) kpriceOption {
	return func(m *KPriceMutation) {
		m.oldValue = func(context.Context) (*KPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KPrice entities.
func (m *KPriceMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KPriceMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KPriceMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KPriceMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KPriceMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KPrice entity.
// If the KPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPriceMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *KPriceMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *KPriceMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KPriceMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KPriceMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KPriceMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KPrice entity.
// If the KPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPriceMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *KPriceMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *KPriceMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KPriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KPriceMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KPriceMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KPrice entity.
// If the KPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPriceMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *KPriceMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *KPriceMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KPriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTokenPairID sets the "token_pair_id" field.
func (m *KPriceMutation) SetTokenPairID(u uint32) {
	m.token_pair_id = &u
	m.addtoken_pair_id = nil
}

// TokenPairID returns the value of the "token_pair_id" field in the mutation.
func (m *KPriceMutation) TokenPairID() (r uint32, exists bool) {
	v := m.token_pair_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenPairID returns the old "token_pair_id" field's value of the KPrice entity.
// If the KPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPriceMutation) OldTokenPairID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenPairID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenPairID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenPairID: %w", err)
	}
	return oldValue.TokenPairID, nil
}

// AddTokenPairID adds u to the "token_pair_id" field.
func (m *KPriceMutation) AddTokenPairID(u int32) {
	if m.addtoken_pair_id != nil {
		*m.addtoken_pair_id += u
	} else {
		m.addtoken_pair_id = &u
	}
}

// AddedTokenPairID returns the value that was added to the "token_pair_id" field in this mutation.
func (m *KPriceMutation) AddedTokenPairID() (r int32, exists bool) {
	v := m.addtoken_pair_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenPairID resets all changes to the "token_pair_id" field.
func (m *KPriceMutation) ResetTokenPairID() {
	m.token_pair_id = nil
	m.addtoken_pair_id = nil
}

// SetPrice sets the "price" field.
func (m *KPriceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *KPriceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the KPrice entity.
// If the KPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPriceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *KPriceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *KPriceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *KPriceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTime sets the "time" field.
func (m *KPriceMutation) SetTime(u uint32) {
	m.time = &u
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *KPriceMutation) Time() (r uint32, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the KPrice entity.
// If the KPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KPriceMutation) OldTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds u to the "time" field.
func (m *KPriceMutation) AddTime(u int32) {
	if m.addtime != nil {
		*m.addtime += u
	} else {
		m.addtime = &u
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *KPriceMutation) AddedTime() (r int32, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTime resets all changes to the "time" field.
func (m *KPriceMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
}

// Where appends a list predicates to the KPriceMutation builder.
func (m *KPriceMutation) Where(ps ...predicate.KPrice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KPriceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KPrice).
func (m *KPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KPriceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, kprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kprice.FieldDeletedAt)
	}
	if m.token_pair_id != nil {
		fields = append(fields, kprice.FieldTokenPairID)
	}
	if m.price != nil {
		fields = append(fields, kprice.FieldPrice)
	}
	if m.time != nil {
		fields = append(fields, kprice.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kprice.FieldCreatedAt:
		return m.CreatedAt()
	case kprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case kprice.FieldDeletedAt:
		return m.DeletedAt()
	case kprice.FieldTokenPairID:
		return m.TokenPairID()
	case kprice.FieldPrice:
		return m.Price()
	case kprice.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kprice.FieldTokenPairID:
		return m.OldTokenPairID(ctx)
	case kprice.FieldPrice:
		return m.OldPrice(ctx)
	case kprice.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown KPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kprice.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kprice.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kprice.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kprice.FieldTokenPairID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenPairID(v)
		return nil
	case kprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case kprice.FieldTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown KPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KPriceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, kprice.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, kprice.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, kprice.FieldDeletedAt)
	}
	if m.addtoken_pair_id != nil {
		fields = append(fields, kprice.FieldTokenPairID)
	}
	if m.addprice != nil {
		fields = append(fields, kprice.FieldPrice)
	}
	if m.addtime != nil {
		fields = append(fields, kprice.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kprice.FieldCreatedAt:
		return m.AddedCreatedAt()
	case kprice.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case kprice.FieldDeletedAt:
		return m.AddedDeletedAt()
	case kprice.FieldTokenPairID:
		return m.AddedTokenPairID()
	case kprice.FieldPrice:
		return m.AddedPrice()
	case kprice.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kprice.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case kprice.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case kprice.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case kprice.FieldTokenPairID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenPairID(v)
		return nil
	case kprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case kprice.FieldTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown KPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KPriceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KPriceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KPriceMutation) ResetField(name string) error {
	switch name {
	case kprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kprice.FieldTokenPairID:
		m.ResetTokenPairID()
		return nil
	case kprice.FieldPrice:
		m.ResetPrice()
		return nil
	case kprice.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown KPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KPriceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KPriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KPriceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KPriceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KPriceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KPrice edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	address       *string
	site          *string
	icon          *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uint32) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TokenMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TokenMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TokenMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TokenMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TokenMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TokenMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TokenMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TokenMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAddress sets the "address" field.
func (m *TokenMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TokenMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *TokenMutation) ResetAddress() {
	m.address = nil
}

// SetSite sets the "site" field.
func (m *TokenMutation) SetSite(s string) {
	m.site = &s
}

// Site returns the value of the "site" field in the mutation.
func (m *TokenMutation) Site() (r string, exists bool) {
	v := m.site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old "site" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldSite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ResetSite resets all changes to the "site" field.
func (m *TokenMutation) ResetSite() {
	m.site = nil
}

// SetIcon sets the "icon" field.
func (m *TokenMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TokenMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *TokenMutation) ResetIcon() {
	m.icon = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, token.FieldDeletedAt)
	}
	if m.address != nil {
		fields = append(fields, token.FieldAddress)
	}
	if m.site != nil {
		fields = append(fields, token.FieldSite)
	}
	if m.icon != nil {
		fields = append(fields, token.FieldIcon)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldDeletedAt:
		return m.DeletedAt()
	case token.FieldAddress:
		return m.Address()
	case token.FieldSite:
		return m.Site()
	case token.FieldIcon:
		return m.Icon()
	case token.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case token.FieldAddress:
		return m.OldAddress(ctx)
	case token.FieldSite:
		return m.OldSite(ctx)
	case token.FieldIcon:
		return m.OldIcon(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case token.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case token.FieldSite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case token.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, token.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.AddedCreatedAt()
	case token.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case token.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case token.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case token.FieldAddress:
		m.ResetAddress()
		return nil
	case token.FieldSite:
		m.ResetSite()
		return nil
	case token.FieldIcon:
		m.ResetIcon()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Token edge %s", name)
}

// TokenPairMutation represents an operation that mutates the TokenPair nodes in the graph.
type TokenPairMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	token_one_id    *uint32
	addtoken_one_id *int32
	token_two_id    *uint32
	addtoken_two_id *int32
	remark          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TokenPair, error)
	predicates      []predicate.TokenPair
}

var _ ent.Mutation = (*TokenPairMutation)(nil)

// tokenpairOption allows management of the mutation configuration using functional options.
type tokenpairOption func(*TokenPairMutation)

// newTokenPairMutation creates new mutation for the TokenPair entity.
func newTokenPairMutation(c config, op Op, opts ...tokenpairOption) *TokenPairMutation {
	m := &TokenPairMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenPair,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenPairID sets the ID field of the mutation.
func withTokenPairID(id uint32) tokenpairOption {
	return func(m *TokenPairMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenPair
		)
		m.oldValue = func(ctx context.Context) (*TokenPair, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenPair.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenPair sets the old TokenPair of the mutation.
func withTokenPair(node *TokenPair) tokenpairOption {
	return func(m *TokenPairMutation) {
		m.oldValue = func(context.Context) (*TokenPair, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenPairMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenPairMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenPair entities.
func (m *TokenPairMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenPairMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenPairMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenPair.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenPairMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenPairMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TokenPair entity.
// If the TokenPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPairMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *TokenPairMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *TokenPairMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenPairMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenPairMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenPairMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TokenPair entity.
// If the TokenPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPairMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *TokenPairMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *TokenPairMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenPairMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TokenPairMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TokenPairMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TokenPair entity.
// If the TokenPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPairMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *TokenPairMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *TokenPairMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TokenPairMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetTokenOneID sets the "token_one_id" field.
func (m *TokenPairMutation) SetTokenOneID(u uint32) {
	m.token_one_id = &u
	m.addtoken_one_id = nil
}

// TokenOneID returns the value of the "token_one_id" field in the mutation.
func (m *TokenPairMutation) TokenOneID() (r uint32, exists bool) {
	v := m.token_one_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenOneID returns the old "token_one_id" field's value of the TokenPair entity.
// If the TokenPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPairMutation) OldTokenOneID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenOneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenOneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenOneID: %w", err)
	}
	return oldValue.TokenOneID, nil
}

// AddTokenOneID adds u to the "token_one_id" field.
func (m *TokenPairMutation) AddTokenOneID(u int32) {
	if m.addtoken_one_id != nil {
		*m.addtoken_one_id += u
	} else {
		m.addtoken_one_id = &u
	}
}

// AddedTokenOneID returns the value that was added to the "token_one_id" field in this mutation.
func (m *TokenPairMutation) AddedTokenOneID() (r int32, exists bool) {
	v := m.addtoken_one_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenOneID resets all changes to the "token_one_id" field.
func (m *TokenPairMutation) ResetTokenOneID() {
	m.token_one_id = nil
	m.addtoken_one_id = nil
}

// SetTokenTwoID sets the "token_two_id" field.
func (m *TokenPairMutation) SetTokenTwoID(u uint32) {
	m.token_two_id = &u
	m.addtoken_two_id = nil
}

// TokenTwoID returns the value of the "token_two_id" field in the mutation.
func (m *TokenPairMutation) TokenTwoID() (r uint32, exists bool) {
	v := m.token_two_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenTwoID returns the old "token_two_id" field's value of the TokenPair entity.
// If the TokenPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPairMutation) OldTokenTwoID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenTwoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenTwoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenTwoID: %w", err)
	}
	return oldValue.TokenTwoID, nil
}

// AddTokenTwoID adds u to the "token_two_id" field.
func (m *TokenPairMutation) AddTokenTwoID(u int32) {
	if m.addtoken_two_id != nil {
		*m.addtoken_two_id += u
	} else {
		m.addtoken_two_id = &u
	}
}

// AddedTokenTwoID returns the value that was added to the "token_two_id" field in this mutation.
func (m *TokenPairMutation) AddedTokenTwoID() (r int32, exists bool) {
	v := m.addtoken_two_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenTwoID resets all changes to the "token_two_id" field.
func (m *TokenPairMutation) ResetTokenTwoID() {
	m.token_two_id = nil
	m.addtoken_two_id = nil
}

// SetRemark sets the "remark" field.
func (m *TokenPairMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TokenPairMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the TokenPair entity.
// If the TokenPair object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPairMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TokenPairMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[tokenpair.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TokenPairMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[tokenpair.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TokenPairMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, tokenpair.FieldRemark)
}

// Where appends a list predicates to the TokenPairMutation builder.
func (m *TokenPairMutation) Where(ps ...predicate.TokenPair) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenPairMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TokenPair).
func (m *TokenPairMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenPairMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, tokenpair.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tokenpair.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tokenpair.FieldDeletedAt)
	}
	if m.token_one_id != nil {
		fields = append(fields, tokenpair.FieldTokenOneID)
	}
	if m.token_two_id != nil {
		fields = append(fields, tokenpair.FieldTokenTwoID)
	}
	if m.remark != nil {
		fields = append(fields, tokenpair.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenPairMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenpair.FieldCreatedAt:
		return m.CreatedAt()
	case tokenpair.FieldUpdatedAt:
		return m.UpdatedAt()
	case tokenpair.FieldDeletedAt:
		return m.DeletedAt()
	case tokenpair.FieldTokenOneID:
		return m.TokenOneID()
	case tokenpair.FieldTokenTwoID:
		return m.TokenTwoID()
	case tokenpair.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenPairMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenpair.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tokenpair.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tokenpair.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tokenpair.FieldTokenOneID:
		return m.OldTokenOneID(ctx)
	case tokenpair.FieldTokenTwoID:
		return m.OldTokenTwoID(ctx)
	case tokenpair.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown TokenPair field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenPairMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenpair.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tokenpair.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tokenpair.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tokenpair.FieldTokenOneID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenOneID(v)
		return nil
	case tokenpair.FieldTokenTwoID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenTwoID(v)
		return nil
	case tokenpair.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown TokenPair field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenPairMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, tokenpair.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, tokenpair.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, tokenpair.FieldDeletedAt)
	}
	if m.addtoken_one_id != nil {
		fields = append(fields, tokenpair.FieldTokenOneID)
	}
	if m.addtoken_two_id != nil {
		fields = append(fields, tokenpair.FieldTokenTwoID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenPairMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokenpair.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tokenpair.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case tokenpair.FieldDeletedAt:
		return m.AddedDeletedAt()
	case tokenpair.FieldTokenOneID:
		return m.AddedTokenOneID()
	case tokenpair.FieldTokenTwoID:
		return m.AddedTokenTwoID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenPairMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokenpair.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tokenpair.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case tokenpair.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case tokenpair.FieldTokenOneID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenOneID(v)
		return nil
	case tokenpair.FieldTokenTwoID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenTwoID(v)
		return nil
	}
	return fmt.Errorf("unknown TokenPair numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenPairMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokenpair.FieldRemark) {
		fields = append(fields, tokenpair.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenPairMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenPairMutation) ClearField(name string) error {
	switch name {
	case tokenpair.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown TokenPair nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenPairMutation) ResetField(name string) error {
	switch name {
	case tokenpair.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tokenpair.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tokenpair.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tokenpair.FieldTokenOneID:
		m.ResetTokenOneID()
		return nil
	case tokenpair.FieldTokenTwoID:
		m.ResetTokenTwoID()
		return nil
	case tokenpair.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown TokenPair field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenPairMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenPairMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenPairMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenPairMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenPairMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenPairMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenPairMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TokenPair unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenPairMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TokenPair edge %s", name)
}
